Song Registration Algorithm - 
_____________________

	The purpose of this Algorithm is to efficiently insert a song to the database.

Variables Explained : 

	mp3File - The input to the system is a mp3 file.

	songID - When registering a song in the database unique ID will be generated for each song.

	int[] peaks - Frequency values which have maximum amplitudes selected from each frequency range will be added to this array. Size of this array will be six since six frequency ranges are chosen.

	List<int[]> peakList - Peaks selected from frequency ranges are stored in peaks array. This consecutive arrays will be added to this list to generate hashes. 

	int time - Time value is given for each hash. When a hash is generated time value is incremented and assigned to the hash.

	double[] pcm - Pulse Code Modulation data is kept in this array.

	String hash - Generated each hash

	TreeMap<String, SongInfo> hashMap - SongInfo Object consist of songID and the time value of a hash. Generated hash and respective songInfo object for the hash is added to hashMap treemap.
	
Algorithm Logic Explained :

	The song registration algorithm takes two inputs. They are the MP3 file of the song and the autogenerated song ID.
	The following variables are initialized on registration.
		peaks, which is an integer array
		peakList, which is a list of peaks
		time
		pcm, a double array
		hash, kept as a string and a 
		hashMap whose purpose are explained above under the section titled "Variables Explained".
	After initializing, we decode the MP3 File into pcm data. Then until the end of this decoded MP3 File of the song that we are inserting to the system, the following process is repeated.
	
		Decode() - After decoding 512 wise samples will be added to buffers.

		Time value will be incremented for each each buffer.

		Monophonic() - Buffer data will be converted into monophonic data if there are sterophonic data.
		
		HammingWindow() - Hamming Window is applied to the buffer.
		
		RealFFT() - Time domain data will be converted into frequency domain data using Furior Transformation and here, Fast Furior Transformation is used.
		
		GetPeaks() - For each buffer, frequencies with highest magnitudes will be selected from six frequency ranges.
		
		GenerateHash() - Using frequencies of four consecutive buffers, one hash is generated.

		Then the generated hash and the SongInfo object which consists of songID and time will be added to the hashMap.
		The first peak set will  be removed from the peakList.
		
	Then after all hashes are generated, the hashes will be added to the database.	

_________________________________________________________________________________________________________________________________________________________________________________________________

Matching Algorithm -
____________________ 

	The purpose of this algorithm is to find songs which is being played in the radio stream. 

Variables Explained :

	stream - Broadcasted radio stream

	int songTimes[SONGCOUNT] - When a stream hash is matched with a hash in the database song, time values of each hash is stored in this array.

	double regressionScores[SONGCOUNT] - regression scores for songs are kept in this array.

	LinkedList<int[]> slidingWindow - Song matches are found using a sliding window. Data needed for this purpose are kept in this list.

Algorithm Logic Explained :

	The matching algorithm takes one input. It is the broadcast stream from the radio. 
	The following variables are initialized on matching.
		songTimes, which is an integer array
		regressionScores, which is a double array 
		slidingWindow, a linked list containing integer arrays		

	As described in the insertion algorithm above, the hashes are generated for the broadcasted stream before the identification process. The hashes are generated same as in the insertion algorithm.

		Decode() - After decoding 512 wise samples will be added to buffers.

		Time value will be incremented for each each buffer.

		Monophonic() - Buffer data will be converted into monophonic data if there are sterophonic data.

		HammingWindow() - Hamming Window is applied to the buffer.

		RealFFT() - Time domain data will be converted into frequency domain data using Furior Transformation and here, Fast Furior Transformation is used.

		GetPeaks() - For each buffer, frequencies with highest magnitudes will be selected from six frequency ranges.

		GenerateHash() - Using frequencies of four consecutive buffers, one hash is generated.
	
	After hashes are generated,	

	QueryDB() - For each generated hash, the database is searched to find whether there are any matches for the generated hash. If any match is found the time and the songID will be added to songInfo object and that object will be added to songInfoList.

	Reset() - If a match is found, the time value for the matched hash from the database is stored in the songTimes[] array. If there is no match with a song, 0 will be added as the matching time.

	For each songInfo object in songInfoList, time of the songInfo object is added to the index of the relavant songID in the songTimes array. If there is two matches for a song, only first match is taken since some parts are being played in a song more than once. This songTimes array is added to slidingWindow LinkedList. If size of the slidingWindow is greater than the given maximum sliding window size, integer array which is in the 0th index is removed. 

	song variable is initialized to 0.

		SelectMatchesForSong() - select a given song idâ€™s time array from the slidingWindow.

		PickSameGapMatches() - filter only the matches that have the same gap in StreamTime and SongTime.

		matchSet - set of (SongTime, StreamTime)

		PickClosetMatches() = Pick points which are closest to y = x (y = SongTime, x = StreamTime)

		GetRegressionScore() - Get the regression score of the selected points.

	After returning regression scores select songs which has regression score greater than the given threshold value. 


